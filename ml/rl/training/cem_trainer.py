#!/usr/bin/env python3
# Copyright (c) Facebook, Inc. and its affiliates. All rights reserved.
"""
The Trainer for Cross-Entropy Method. The idea is that an ensemble of
 world models are fitted to predict transitions and reward functions.
A cross entropy method-based planner will then plan the best next action
based on simulation data generated by the fitted world models.

The idea is inspired by: https://arxiv.org/abs/1805.12114
"""
import logging
from typing import List, Union

import ml.rl.types as rlt
import numpy as np
import torch
from ml.rl.models.cem_planner import CEMPlannerNetwork
from ml.rl.parameters import CEMParameters
from ml.rl.training.rl_trainer_pytorch import RLTrainer
from ml.rl.training.training_data_page import TrainingDataPage
from ml.rl.training.world_model.mdnrnn_trainer import MDNRNNTrainer


logger = logging.getLogger(__name__)


class CEMTrainer(RLTrainer):
    def __init__(
        self,
        cem_planner_network: CEMPlannerNetwork,
        world_model_trainers: List[MDNRNNTrainer],
        parameters: CEMParameters,
        use_gpu: bool = False,
    ) -> None:
        super().__init__(parameters.rl, use_gpu=use_gpu)
        self.cem_planner_network = cem_planner_network
        self.world_model_trainers = world_model_trainers
        self.minibatch_size = parameters.mdnrnn.minibatch_size

    def train(self, training_batch, batch_first=False):
        if isinstance(training_batch, TrainingDataPage):
            training_batch = training_batch.as_cem_training_batch(batch_first)
        assert (
            type(training_batch) is rlt.PreprocessedTrainingBatch
            and type(training_batch.training_input)
            is rlt.PreprocessedMemoryNetworkInput
        )
        for i, trainer in enumerate(self.world_model_trainers):
            losses = trainer.train(training_batch, batch_first=batch_first)
            logger.info(
                "{}-th minibatch {}-th model: \n"
                "loss={}, bce={}, gmm={}, mse={} \n"
                "cum loss={}, cum bce={}, cum gmm={}, cum mse={}\n".format(
                    self.minibatch,
                    i,
                    losses["loss"],
                    losses["bce"],
                    losses["gmm"],
                    losses["mse"],
                    np.mean(trainer.cum_loss),
                    np.mean(trainer.cum_bce),
                    np.mean(trainer.cum_gmm),
                    np.mean(trainer.cum_mse),
                )
            )
        self.minibatch += 1
        logger.info("")

    @torch.no_grad()  # type: ignore
    def internal_prediction(
        self, state: torch.Tensor
    ) -> Union[rlt.SacPolicyActionSet, rlt.DqnPolicyActionSet]:
        """
        Only used by Gym. Return the predicted next action
        """
        input = rlt.PreprocessedState(
            state=rlt.PreprocessedFeatureVector(float_features=state)
        )
        output = self.cem_planner_network(input)
        if not self.cem_planner_network.discrete_action:
            return rlt.SacPolicyActionSet(greedy=output, greedy_propensity=1.0)
        return rlt.DqnPolicyActionSet(greedy=output[0])

    @torch.no_grad()  # type: ignore
    def internal_reward_estimation(self, input):
        """
        Only used by Gym
        """
        raise NotImplementedError()
